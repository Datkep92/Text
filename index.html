<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>OCR b·∫£ng t·ª´ PDF (scan)</title>
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/build/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.1/dist/tesseract.min.js"></script>
  <style>
    body { font-family: Arial; margin: 20px; }
    canvas { display: none; }
    table { border-collapse: collapse; margin-top: 20px; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 5px; font-size: 13px; }
  </style>
</head>
<body>

<h3>üìÑ OCR b·∫£ng t·ª´ file PDF (scan ·∫£nh)</h3>
<input type="file" id="pdfInput" accept="application/pdf"><br>
<div id="status">Ch∆∞a x·ª≠ l√Ω</div>
<canvas id="pdfCanvas"></canvas>
<div id="output"></div>

<script>
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/build/pdf.worker.min.js';

document.getElementById('pdfInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const status = document.getElementById('status');
  const canvas = document.getElementById('pdfCanvas');
  const ctx = canvas.getContext('2d');
  const output = document.getElementById('output');

  status.innerText = 'üì• ƒêang load PDF...';

  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  const page = await pdf.getPage(1);
  const viewport = page.getViewport({ scale: 2.0 });

  canvas.width = viewport.width;
  canvas.height = viewport.height;

  await page.render({ canvasContext: ctx, viewport }).promise;

  status.innerText = 'üîç ƒêang OCR...';

  const result = await Tesseract.recognize(canvas.toDataURL(), 'vie', {
    logger: m => console.log(m)
  });

  const lines = groupByLines(result.data.words);
  const parsedRows = lines.map(parseRowByX);
  displayTable(parsedRows);
  status.innerText = `‚úÖ ƒê√£ tr√≠ch xu·∫•t ${parsedRows.length} d√≤ng`;
});

// Gom t·ª´ theo y g·∫ßn nhau
function groupByLines(words) {
  const lines = {};
  for (let w of words) {
    const y = Math.round(w.bbox.y0 / 5) * 5;
    if (!lines[y]) lines[y] = [];
    lines[y].push(w);
  }

  const sortedY = Object.keys(lines).sort((a, b) => a - b);
  return sortedY.map(y => lines[y].sort((a, b) => a.bbox.x0 - b.bbox.x0));
}

// Chia theo x ƒë·ªÉ t√°ch c·ªôt
function parseRowByX(words) {
  const row = ['', '', '', '', '', '', '', ''];
  for (let w of words) {
    const x = w.bbox.x0;

    if (x < 40) row[0] += ' ' + w.text;         // STT
    else if (x < 160) row[1] += ' ' + w.text;   // T√≠nh ch·∫•t / lo·∫°i
    else if (x < 330) row[2] += ' ' + w.text;   // T√™n h√†ng
    else if (x < 400) row[3] += ' ' + w.text;   // ƒêVT
    else if (x < 470) row[4] += ' ' + w.text;   // SL
    else if (x < 570) row[5] += ' ' + w.text;   // ƒê∆°n gi√°
    else if (x < 630) row[6] += ' ' + w.text;   // Chi·∫øt kh·∫•u
    else row[7] += ' ' + w.text;                // Th√†nh ti·ªÅn
  }
  return row.map(c => c.trim());
}

// Hi·ªÉn th·ªã b·∫£ng k·∫øt qu·∫£
function displayTable(rows) {
  let html = `<table><thead><tr>
    <th>STT</th><th>T√≠nh ch·∫•t</th><th>T√™n h√†ng</th><th>ƒêVT</th>
    <th>S·ªë l∆∞·ª£ng</th><th>ƒê∆°n gi√°</th><th>Chi·∫øt kh·∫•u</th><th>Th√†nh ti·ªÅn</th>
  </tr></thead><tbody>`;

  rows.forEach(r => {
    if (r.filter(Boolean).length >= 5) {
      html += '<tr>' + r.map(c => `<td>${c}</td>`).join('') + '</tr>';
    }
  });

  html += '</tbody></table>';
  document.getElementById('output').innerHTML = html;
}
</script>
</body>
</html>